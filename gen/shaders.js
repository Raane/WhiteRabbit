SHADERS={};SHADERS.glitch = {uniforms: {
    tDiffuse: { type: 't', value: null },
    time: { type: 'f', value: null },
    amount: { type: 'f', value: 0}
}
,vertexShader: "varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader: "uniform float time;\nuniform float amount;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\n\nfloat ranieyy(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main(void) {\n    float size = 8.;\n    vec2 pos = vec2(floor(size * 2. * vUv.x + vUv.y * vUv.y * amount * cos(vUv.x * time)) / 2. / size,\n                    floor(size * 18. * vUv.y * sin(time)) / 18. / size);\n    float random = ranieyy(pos + time);\n    vec4 img = texture2D(tDiffuse, vUv);\n    vec4 left = texture2D(tDiffuse, vUv - 0.1);\n    vec4 right = texture2D(tDiffuse, vUv + 0.1);\n    vec4 sine = texture2D(tDiffuse, vec2(sin(vUv.x * 37.), sin(vUv.y * 23.)));\n    vec4 color = vec4(1.);\n    if(random < 0.333) {\n        color = vec4(right.r, img.g, img.b, 0.98) + sine;\n    } else if(random < 0.79) {\n        color = vec4(img.b, left.r, img.g, 0.7) * sine;\n    } else {\n        color = vec4(right.r, left.g / 2., right.b + sine.b * .99, 1.);\n    }\n    gl_FragColor = (1. - amount) * img * .99 + amount * color;\n}\n"};
SHADERS.glow = {uniforms: { 
  "c": {type: "f", value: 1.0},
  "p": {type: "f", value: 1.4},
  "glowColor": {type: "c", value: null},
  "viewVector": {type: "v3", value: null}
}
,vertexShader: "uniform vec3 viewVector;\nuniform float c;\nuniform float p;\nvarying float intensity;\n\nvoid main() {\n    vec3 vNormal = normalize(normalMatrix * normal);\n    vec3 vNormel = normalize(normalMatrix * viewVector);\n    intensity = pow(c - dot(vNormal, vNormel), p);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader: "uniform vec3 glowColor;\nvarying float intensity;\n\nvoid main() {\n    vec3 glow = glowColor * intensity;\n    gl_FragColor = vec4(glow, 1.0);\n}\n"};
SHADERS.img = {uniforms: {
    "tDiffuse": { "type": 't', "value": null },
    "img": { "type": 't', "value": null }
}
,vertexShader: "varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader: "varying mediump vec2 vUv;\nuniform sampler2D img;\n\nvoid main() {\n    gl_FragColor = texture2D(img, vUv);\n}\n"};
SHADERS.mandelbrot = {uniforms: {
    "time": { "type": "f", "value": 0 },
    "frame": { "type": "f", "value": 0 },
    "stab": { "type": "f", "value": 0 },
    "resolution": { "type": "v2", "value": null },
    "zoomCoordinate": { "type": "v2", "value": { "x": 0, "y": 0 } },
    "textImage": { "type": "t", "value": null },
    "tDiffuse": { "type": "t", "value": null }
}

,vertexShader: "varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader: "uniform float time;\nuniform float frame;\nuniform float stab;\nuniform vec2 resolution;\nuniform vec2 zoomCoordinate;\nuniform sampler2D textImage;\nuniform sampler2D tDiffuse;\n\n#define PI 3.14159265358979323846\nvarying vec2 vUv;\n\nconst int depth = 256;\n\nvec2 complexMult(vec2 a, vec2 b)\n{\n    float real = a.x * b.x - a.y * b.y;\n    float complex = a.y * b.x + a.x * b.y;\n    return vec2(real, complex);\n}\n\nfloat mandelbrot(vec2 c)\n{\n    vec2 z = vec2(0.0, 0.0);\n\n    int depth_reached = 0;\n    for (int i=0; i<depth; i++) {\n        if (dot(z, z) > 4.0) {\n            depth_reached = i;\n            break;\n        }\n        z = complexMult(z, z) + c;\n    }\n\n    return float(depth_reached) / float(depth);\n}\n\n\nvoid main(void)\n{\n    float framesPerBeat = 32.727272727272727273;\n    vec2 uv = (gl_FragCoord.xy / resolution);\n    uv -= vec2(0.5, 0.5);\n\n    vec3 color = vec3(0.56, 0.69, 0.60) * 0.8;\n\n    float ratio = 16. / 9.;\n\n    if(0.5 + uv.x * ratio + 1.> uv.y + mod(0. / 3. + frame / 127. - 1., 2.)) {\n        uv.x -= 0.1 * stab;\n        color *= 1. + stab * 0.8;\n    }\n\n    if(0.5 + uv.x * ratio + 1.> uv.y + mod(1. / 3. + frame / 127. - 1., 2.)) {\n        uv.x -= 0.1 * stab;\n        color *= 1. + stab * 0.8;\n    }\n\n    if(0.5 + uv.x * ratio + 1.> uv.y + mod(2. / 3. + frame / 127. - 1., 2.)) {\n        uv.x -= 0.1 * stab;\n        color *= 1. + stab * 0.8;\n    }\n\n    if(0.5 + uv.x * ratio + 1.> uv.y + mod(3. / 3. + frame / 127. - 1., 2.)) {\n        uv.x -= 0.1 * stab;\n        color *= 1. + stab * 0.8;\n    }\n\n    if(0.5 + uv.x * ratio + 1.> uv.y + mod(4. / 3. + frame / 127. - 1., 2.)) {\n        uv.x -= 0.1 * stab;\n        color *= 1. + stab * 0.8;\n    }\n\n    if(0.5 + uv.x * ratio + 1.> uv.y + mod(5. / 3. + frame / 127. - 1., 2.)) {\n        uv.x -= 0.1 * stab;\n        color *= 1. + stab * 0.8;\n    }\n\n    float zoom = pow(2.0, -time) * 3.5;\n    zoom += 0.00005 * sin(frame / framesPerBeat * PI * 2.);\n\n   vec2 lastTranslate = vec2(0., 0.);\n\n   if(frame >= 6778. + 136.) {\n        zoom -= mix(0., .003, clamp((frame - 6778. - 136.) / 100., 0., 1.));\n        lastTranslate -= mix(vec2(0.),\n                             vec2(0.005, -0.001),\n                             clamp((frame - 6778. - 136.) / 100., 0., 1.));\n   }\n\n    uv *= vec2(3.5, 2.0) * zoom;\n    /*\n    */\n\n    float angle = 0.02 * sin(frame / framesPerBeat * PI);\n    uv = vec2(uv.x * cos(angle) - uv.y * sin(angle),\n              uv.x * sin(angle) + uv.y * cos(angle));\n\n    uv += zoomCoordinate + lastTranslate;\n\n    /*\n    */\n\n    /*\n    */\n\n    vec4 textImageColor = texture2D(textImage, vUv);\n\n    vec2 stepX = vec2(1. / resolution.x, 0.);\n    vec2 stepY = vec2(0., 1. / resolution.y);\n    float center = mandelbrot(uv);\n\n    float mixer = 0.;\n    if(center <= 0.1) {\n        mixer = 0.;\n    } else if(center > 0.1) {\n        mixer = mix(1., 0., (center - 0.1) / 0.9);\n    } else {\n        mixer = 1.;\n    }\n\n    vec4 mandelbrotColor =\n        mix(\n            vec4(color * stab * 0.2, 1.0),\n            vec4(vec3(color), 1.0),\n            mixer);\n\n    if(mixer < 0.1) {\n        mandelbrotColor = texture2D(tDiffuse, vUv);\n    }\n\n    gl_FragColor = vec4(mix(1.0 - textImageColor.rgb, mandelbrotColor.rgb, 1.0 - textImageColor.a), 1.0);\n}\n"};
SHADERS.noise = {uniforms: {
    tDiffuse: { type: 't', value: null },
    time: { type: 'f', value: null },
    amount: { type: 'f', value: 0},
    width: { type: 'f', value: null},
    height: { type: 'f', value: null}
}
,vertexShader: "varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader: "uniform float time;\nuniform float amount;\nuniform sampler2D tDiffuse;\nuniform float width;\nuniform float height;\nvarying vec2 vUv;\n\nfloat ranieyy(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n    vec4 colorInput = texture2D( tDiffuse, vUv );\n    vec2 pozz = vec2(floor(width*vUv.x)/width, floor(height*vUv.y)/height);\n    vec3 color = vec3(.1, 0.1, 0.1) + vec3(ranieyy(vec2(pozz+time/1009.0)));\n    gl_FragColor = colorInput*(1.0-amount)+amount*vec4(color, 0.1);\n}\n"};
SHADERS.reveal = {uniforms: {
  "texture": {type: "t", value: null},
  "reveal": {type: "f", value: 0.0},
  "alphaBound": {type: "f", value: 0.5}
}
,vertexShader: "varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader: "uniform sampler2D texture;\nuniform float reveal;\nuniform float alphaBound;\n\nvarying vec2 vUv;\n\nvoid main() {\n    vec4 color = texture2D(texture, vUv);\n\n    gl_FragColor = color;\n    if(gl_FragColor.a > alphaBound){\n        gl_FragColor.a = alphaBound;\n    }\n\n    if(vUv.x > reveal && vUv.x < reveal + 0.05){\n       gl_FragColor.a *= 1. - ((vUv.x - reveal)/0.05);\n    }else if(vUv.x >= reveal + 0.05){\n       gl_FragColor.a = 0.;\n    }\n\n    if(reveal == 0.){\n      gl_FragColor.a = 0.;\n    }\n\n}\n"};
SHADERS.shockwave = {uniforms: {
    tDiffuse: { type: 't', value: null },
    time: { type: 'f', value: null },
}
,vertexShader: "varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader: "uniform float time;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\n\n#define PI 3.14159265359\n#define SLOWDOWN 0.8\n#define STARTTIME 0.2\n#define SHOCKTIME PI/SLOWDOWN\n#define SOUNDSPEED 1.5\n\nfloat cross(vec2 uv) {\n    return 1.-abs(abs(uv.x-.5)-abs(uv.y-.5));\n}\n\nfloat dist(vec2 uv, float x, float y) {\n    return sqrt(pow(abs(uv.x-x)*16./9.,2.)+ pow(abs(uv.y-y),2.));\n}\n\nvec2 deltaCoor(vec2 uv, vec2 center) {\n    return vec2(uv.x-center.x, uv.y-center.y);\n}\n\nfloat shockwave(float rawX) {\n    float x = rawX - STARTTIME/SLOWDOWN;\n    float shock = sin(x*50.-PI)/(x*50.-PI);\n    float squareFunction = ceil(x/1e10)-ceil((x-SHOCKTIME)/1e10);\n    return shock*squareFunction*8.;\n}\n\nvoid main() {\n    //vec2 uv = fragCoord.xy / iResolution.xy;\n\n    /*float noiseX = (texture2D(iChannel1, vec2(vUv.x, vUv.y)).r-.5)/50.;\n    float noiseY = (texture2D(iChannel1, vec2(vUv.y, vUv.x)).r-.5)/50.;\n    */\n    float noiseX = 0.0;\n    float noiseY = 0.0;\n    float d = dist(vUv, .5+noiseX,.5+noiseY);\n\n    //float amp = shockwave(iGlobalTime/SLOWDOWN-d*SOUNDSPEED);\n    float amp = shockwave(time/51.-d*SOUNDSPEED);\n    float x = amp*(vUv.x-.5);\n    float y = amp*(vUv.y-.5);\n\n    vec4 image = texture2D(tDiffuse, vec2(vUv.x+x, vUv.y+y));\n    gl_FragColor = image;\n}\n"};
SHADERS.sobelpulse = {uniforms: {
    tDiffuse: { type: 't', value: null },
    time: { type: 'f', value: null },
    amount: { type: 'f', value: null },
}
,vertexShader: "varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader: "uniform float time;\nuniform float amount;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\n\n\nmat3 gx = mat3(\n        1.0,  2.0,  1.0,\n        0.0,  0.0,  0.0,\n        -1.0, -2.0, -1.0\n        );\n\nmat3 gy = mat3(\n        -1.0, 0.0, 1.0,\n        -2.0, 0.0, 2.0,\n        -1.0, 0.0, 1.0\n        );\n\nvec3 edgeColor = vec3(1.0, 0.5, 0.75);\n\nfloat intensity(vec3 pixel) {\n    return (pixel.r + pixel.g + pixel.b) / 3.0;\n}\n\nfloat pixelIntensity(vec2 vUv, vec2 d) {\n    vec3 pix = texture2D(tDiffuse, vUv + d*2. / vec2(1600.,900.)).rgb;\n    return intensity(pix);\n}\n\n\nfloat convolv(mat3 a, mat3 b) {\n    float result = 0.0;\n\n    for (int i=0; i<3; i++) {\n        for (int j=0; j<3; j++) {\n            result += a[i][j] * b[i][j];\n        }\n    }\n\n    return result;\n}\n\nfloat sobel(vec2 vUv) {\n    mat3 pixel = mat3(0.0);\n\n    for (int x=-1; x<2; x++) {\n        for (int y=-1; y<2; y++) {\n            pixel[x+1][y+1] = pixelIntensity(vUv, vec2(float(x), float(y)));\n        }\n    }\n\n    float x = convolv(gx, pixel);\n    float y = convolv(gy, pixel);\n\n    return sqrt(x * x + y * y);\n}\n\nvoid main() {\n    float width = .01;\n    vec4 pixel = texture2D(tDiffuse, vec2(vUv.x, vUv.y));\n    vec4 right = texture2D(tDiffuse, vec2(vUv.x+width, vUv.y));\n    vec4 up = texture2D(tDiffuse, vec2(vUv.x, vUv.y+width));\n    float pixelSum = pixel.r+pixel.g+pixel.b;\n    float rightSum = right.r+right.g+right.b;\n    float upSum = up.r+up.g+up.b;\n    float edge = abs(pixelSum-rightSum)+abs(pixelSum-upSum);\n\n    float s = sobel(vUv);\n    edge = clamp(edge,0.,1.);\n\n    float blackboard = texture2D(tDiffuse,vUv).r;\n\n    //float color = max(edge,0.)*(blackboard*.3)+blackboard*.3;\n    float color = max(s,0.)*(blackboard)+blackboard*.3;\n    \n    gl_FragColor = pixel + clamp(vec4(color),0.,1.)*amount;\n}\n"};
SHADERS.splooshsobel = {uniforms: {
    tDiffuse: { type: 't', value: null },
    bg: { type: 't', value: null },
    time: { type: 'f', value: null },
    bgEnabled: { type: 'f', value: 0.0 }
}
,vertexShader: "varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader: "uniform float time;\nuniform sampler2D tDiffuse;\nuniform sampler2D bg;\nuniform float bgEnabled;\n\nvarying vec2 vUv;\n\n\nmat3 gx = mat3(\n        1.0,  2.0,  1.0,\n        0.0,  0.0,  0.0,\n        -1.0, -2.0, -1.0\n        );\n\nmat3 gy = mat3(\n        -1.0, 0.0, 1.0,\n        -2.0, 0.0, 2.0,\n        -1.0, 0.0, 1.0\n        );\n\nvec3 edgeColor = vec3(1.0, 0.5, 0.75);\n\nfloat intensity(vec3 pixel) {\n    return (pixel.r + pixel.g + pixel.b) / 3.0;\n}\n\nfloat pixelIntensity(vec2 vUv, vec2 d) {\n    vec3 pix = texture2D(tDiffuse, vUv + d*2. / vec2(1600.,900.)).rgb;\n    return intensity(pix);\n}\n\n\nfloat convolv(mat3 a, mat3 b) {\n    float result = 0.0;\n\n    for (int i=0; i<3; i++) {\n        for (int j=0; j<3; j++) {\n            result += a[i][j] * b[i][j];\n        }\n    }\n\n    return result;\n}\n\nfloat sobel(vec2 vUv) {\n    mat3 pixel = mat3(0.0);\n\n    for (int x=-1; x<2; x++) {\n        for (int y=-1; y<2; y++) {\n            pixel[x+1][y+1] = pixelIntensity(vUv, vec2(float(x), float(y)));\n        }\n    }\n\n    float x = convolv(gx, pixel);\n    float y = convolv(gy, pixel);\n\n    return sqrt(x * x + y * y);\n}\n\nvoid main() {\n    float width = .01;\n    vec4 pixel = texture2D(tDiffuse, vec2(vUv.x, vUv.y));\n    vec4 right = texture2D(tDiffuse, vec2(vUv.x+width, vUv.y));\n    vec4 up = texture2D(tDiffuse, vec2(vUv.x, vUv.y+width));\n    float pixelSum = pixel.r+pixel.g+pixel.b;\n    float rightSum = right.r+right.g+right.b;\n    float upSum = up.r+up.g+up.b;\n    float edge = abs(pixelSum-rightSum)+abs(pixelSum-upSum);\n\n    float s = sobel(vUv);\n    edge = clamp(edge,0.,1.);\n\n    float blackboard = texture2D(tDiffuse,vUv).r;\n\n    //float color = max(edge,0.)*(blackboard*.3)+blackboard*.3;\n    float color = max(s,0.)*(blackboard)+blackboard*.3;\n    \n    vec4 outp;\n    outp = pixel + clamp(vec4(color*4.-2.),0.,1.);\n    if(bgEnabled == 1.0 && outp.r < 0.1) {\n        outp = texture2D(bg, vUv);\n    }\n    gl_FragColor = outp;\n}\n"};
SHADERS.tile = {uniforms: {
    multiplier: { type: 'f', value: 1 },
    tDiffuse: { type: 't', value: null }
}
,vertexShader: "varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader: "varying vec2 vUv;\nuniform sampler2D tDiffuse;\nuniform float multiplier;\n\nvoid main() {\n    float x = mod(vUv.x * multiplier, 1.0);\n    float y = mod(vUv.y * multiplier, 1.0);\n    vec2 a = vec2(x, y);\n    gl_FragColor = texture2D(tDiffuse, a);\n}\n"};
SHADERS.toon = {uniforms: {
    tDiffuse: { type: 't', value: null },
    GU: { type: 'f', value: null}
}
,vertexShader: "varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader: "varying mediump vec2 vUv;\nuniform sampler2D tDiffuse;\nuniform mediump float GU;\n\n\nfloat intensity(in vec4 color){\n    float gamma = 2.2;\n    return (.2126 * pow(color.r, gamma) +\n            .7152 * pow(color.g, gamma) +\n            .0722 * pow(color.b, gamma));\n}\n\nfloat sobel(float stepx, float stepy, vec2 center){\n    // get samples around pixel\n    float tleft = intensity(texture2D(tDiffuse,center + vec2(-stepx,stepy)));\n    float left = intensity(texture2D(tDiffuse,center + vec2(-stepx,0)));\n    float bleft = intensity(texture2D(tDiffuse,center + vec2(-stepx,-stepy)));\n    float top = intensity(texture2D(tDiffuse,center + vec2(0,stepy)));\n    float bottom = intensity(texture2D(tDiffuse,center + vec2(0,-stepy)));\n    float tright = intensity(texture2D(tDiffuse,center + vec2(stepx,stepy)));\n    float right = intensity(texture2D(tDiffuse,center + vec2(stepx,0)));\n    float bright = intensity(texture2D(tDiffuse,center + vec2(stepx,-stepy)));\n    float x = tleft + 2.0*left + bleft - tright - 2.0*right - bright;\n    float y = -tleft - 2.0*top - tright + bleft + 2.0 * bottom + bright;\n    float color = sqrt((x*x) + (y*y));\n    return color;\n }\n\nvoid main() {\n    float width = GU * 16.;\n    float height = GU * 9.;\n    float edge = sobel(1. / width, 1. / height, vUv);\n    float lowerBound = 0.5;\n    float upperBound = 0.9;\n    if(edge < upperBound) {\n        edge = mix(0., lowerBound, (edge - lowerBound) / (upperBound - lowerBound));\n    }\n    edge = 1. - edge;\n\n    vec4 color = texture2D(tDiffuse, vUv);\n    float posterizeSteps = 3.;\n    float posterized = intensity(color);\n    if(posterized < 0.3) {\n        posterized = 0.6;\n    } else if (posterized < 0.8){\n        posterized = 0.8;\n    } else {\n        posterized = 1.;\n    }\n\n    gl_FragColor = vec4(color.xyz * posterized * (0.8 + 0.2 * edge), 1.);\n}\n"};
SHADERS.tunnel = {uniforms: {
    tDiffuse: { type: 't', value: null },
    wall: { type: 't', value: null },
    textImage: { type: 't', value: null },
    tunnelAmount: { type: 'f', value: 0},
    metaballAmount: { type: 'f', value: 0},
    throb: { type: 'f', value: 0},
    opacity: { type: 'f', value: 0},
    t: { type: 'f', value: 0}
}
,vertexShader: "varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader: "uniform sampler2D tDiffuse;\nuniform sampler2D wall;\nuniform sampler2D textImage;\nuniform float t;\nuniform float tunnelAmount;\nuniform float metaballAmount;\nuniform float throb;\nuniform float opacity;\nvarying vec2 vUv;\n\n\nfloat metaball(vec3 p){\n    float fv[5];\n    float tt = t * 0.01;\n    fv[0] = length(p - vec3(2.0 * sin(tt + 3.14), 0.1, 1.0 * cos(tt + 3.1)));\n    fv[1] = length(p - vec3(3.1 * sin(tt), sin(tt), 0.5 * cos(tt * 0.7)));\n    fv[2] = length(p - vec3(1.2 * sin(tt), 2.0 * cos(tt * 1.4), 0.1 * cos(tt + 2.1)));\n    fv[3] = length(p - vec3(2.0 * cos(tt), 2.0 * cos(tt * 1.3), 1.5 * cos(tt)));\n    fv[4] = length(p - vec3(2.5 * sin(tt * 0.3), 2.0 * cos(tt * 0.6), 0.5 * sin(tt)));\n    float len = 0.0;\n    float fs = .5;\n    for (int i = 0; i < 5; i ++) {\n        len += fs / (fv[i] * fv[i]);\n    }\n    return 1. - min(16.0, len);\n}\n\n\nvoid main(void)\n{\n    vec2 uv = vUv;\n\n    vec2 center = vec2(0.5, 0.5);\n\n    center.x += .2 * sin(t * 0.017) * tunnelAmount;\n    center.y += .2 * cos(t * 0.015) * tunnelAmount;\n\n    vec2 dist = (uv - center);\n    dist.x *= 16.;\n    dist.y *= 9.;\n    float radius = 9. / length(dist) + t * 0.05;\n    uv = mix(\n            uv,\n            mod(vec2(6. / 3.1415926535 / 2. * atan(dist.y / 16., dist.x / 16.) + 2. * sin(t * 0.005) / length(dist) + t * 0.002,\n                     radius),\n                1.),\n            tunnelAmount);\n\n    vec2 tiles = vec2(32., 18.);\n\n    vec4 diffuse = texture2D(tDiffuse, (0.5 + floor(uv * tiles)) / tiles);\n    diffuse += 0.02;\n    vec4 wallDiffuse = texture2D(wall, 0.01 + floor(uv * tiles) / tiles);\n    float p = 1.0 - (diffuse.r + diffuse.g + diffuse.b) / 3.;\n    p = min(max(p * 3.0 - 1.8, 0.1), 10.0);\n    p = 1.;\n    \n    vec2 r = mod(uv * tiles, 1.0);\n    r = vec2(pow(r.x - 0.5, 2.0), pow(r.y - 0.5, 2.0));\n    p *= 1.0 - pow(min(1.0, 12.0 * dot(r, r)), 2.0);\n    wallDiffuse *= p;\n\n    float lighting = 1. - 4. * pow(length(dist) / 16. - 0.5, 2.);\n    lighting = clamp(0., 1., lighting);\n\n    p = p * mix(1., throb * lighting, tunnelAmount);\n\n    float centerDarkener = mix(1., length(dist * 4.) / length(center * 16.),\n        tunnelAmount);\n\n    centerDarkener = sqrt(centerDarkener);\n\n    /* metaballs */\n    vec3 camera_pos = vec3(0.0, 0.0, -23.0);\n    vec3 org = vec3(center - vUv, -22.);\n    vec3 dir = normalize(org - camera_pos);\n    vec3 P = org.xyz;\n    float d;\n    for (int i = 0; i < 64; i++) {\n        d = metaball(P.xyz * (11. - 10. * metaballAmount));\n        P = P + d * dir;\n    }\n    float fg=min(1.0,20.0/length(P-org));\n    vec4 col = vec4(vec3(fg),1)*fg*fg;\n    col *= vec4(.9, .9, .9, 1.);\n    vec4 orangeLighting = 1. - 8. * pow(length(dist) / 16. - 0.5, 2.) *\n        vec4(9., .9, .9, .1);\n\n    vec4 black = vec4(vec3(0.), 1);\n    col = mix(black, col, metaballAmount);\n    orangeLighting = mix(black, orangeLighting, metaballAmount);\n\n    vec4 outp = diffuse * p + wallDiffuse * throb * centerDarkener + orangeLighting * 0.01;\n\n    if(length(col.xyz) > 0.1) {\n        outp = col;\n    }\n\n    if(t >= 1250.) {\n        outp = mix(outp, outp + vec4(1.), smoothstep(0., 1., (t - 1250.) / 20.));\n    }\n\n    vec4 textImageColor = texture2D(textImage, vUv);\n    outp = vec4(mix(outp.xyz, 1. - textImageColor.xyz, textImageColor.a), 1.);\n\n    gl_FragColor = mix(\n        texture2D(tDiffuse, vUv),\n        outp,\n        opacity);\n}\n"};
SHADERS.vcr = {uniforms: {
    tDiffuse: { type: 't', value: null },
}
,vertexShader: "varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader: "varying mediump vec2 vUv;\nuniform sampler2D tDiffuse;\n\nconst float RADIUS = 0.85;\nconst float SOFTNESS = 0.65;\n\nvoid main() {\n    vec2 position = vUv / vec2(0.6,1.0) - vec2(0.8,0.5) ;\n    float len = length(position);\n    float vignette = 1.0 - smoothstep(RADIUS, RADIUS - SOFTNESS, len);\n    float r = texture2D(tDiffuse, vUv - (vignette * (position * (len * 0.015)))).r;\n    float g = texture2D(tDiffuse, vUv).g;\n    float b = texture2D(tDiffuse, vUv + (vignette * (position * (len * 0.015)))).b;\n    gl_FragColor = vec4(r, g, b, 1.0);\n}\n"};
SHADERS.default = {uniforms: {
    tDiffuse: { type: 't', value: null },
}
,vertexShader: "varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader: "uniform sampler2D tDiffuse;\n\nvarying vec2 vUv;\n\nvoid main() {\n    vec4 colorInput = texture2D( tDiffuse, vUv );\n    gl_FragColor = colorInput;\n}\n"};
SHADERS.multiply = {uniforms: {
    tDiffuse: { type: 't', value: null },
    amount: { type: 'f', value: 0},
    r: { type: 'f', value: 0},
    g: { type: 'f', value: 0},
    b: { type: 'f', value: 0}
}
,vertexShader: "varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader: "uniform float amount;\nuniform float r;\nuniform float g;\nuniform float b;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\n\nvoid main() {\n    vec4 fragColor = texture2D(tDiffuse, vUv);\n    gl_FragColor = vec4(mix(fragColor.r, fragColor.r * r, amount),\n                        mix(fragColor.g, fragColor.g * g, amount),\n                        mix(fragColor.b, fragColor.b * b, amount),\n                        1.);\n}\n"};
SHADERS.vignette = {uniforms: {
    tDiffuse: { type: 't', value: null },
    amount: { type: 'f', value: 0}
}
,vertexShader: "varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader: "uniform sampler2D tDiffuse;\nuniform float amount;\nvarying vec2 vUv;\n\nvoid main() {\n    vec4 original = texture2D(tDiffuse, vUv);\n    float dist = length(vUv - vec2(0.5, 0.5));\n    dist = dist / 0.707;\n    if(dist < 0.) dist = 0.;\n    if(dist > 1.) dist = 1.;\n    dist = dist * dist * dist;\n    gl_FragColor = vec4(original.xyz * (1. - dist * amount), 1.);\n}\n"};
